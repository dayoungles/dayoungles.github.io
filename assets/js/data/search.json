[ { "title": "Jekyll blog new version is finally deployed!", "url": "/posts/finally-deployed/", "categories": "Personal", "tags": "Jekyll", "date": "2021-09-13 08:00:00 +0900", "snippet": "그저 예쁜 블로그 테마를 쓰고 싶었을 뿐인데…나는 그저 예쁜 블로그 테마를 쓰고 싶었을 뿐인데 로컬에서 잘 실행되는 지킬 블로그가, 깃헙에만 올리면 제대로 빌드가 되질 않았다. 거진 일주일 가량을 헤맨 것 같은데(이것만 붙잡고 있었던 것은 아니지만) 기존에 있었던 리포지토리 영향인가 싶어서 기다리다가 잊어버리는 시간 조금과 약간 열받음의 시간 조금을 더해서 원작자의 안내를 살펴보니, workflow에 서술된 대로 동작할 것이다..라는 말이 있어서 찾아보니 .github 디렉토리 안에 넣어둔 deploy.yaml 파일 안에 배포 대상 브랜치가 지정이 되어 있었다. 그러니까 github 리포지토리 내에서 브랜치로 지정하는 것과 별개로, 빌드를 하는 대상을 워크플로우에서 지정하도록 되어있었던 것. 사실 master로 잡혀있었는데, master도 원본이구만 뭐가 문젠가 싶긴 하지만, 결국 브랜치 수정 몇번 끝에 정상적으로 접속이 가능하게 되었다. 매일 들어가서 보진 않더라도 안 돌아가면 열받는다구…최근 근황 정리갑자기 에너지가 돌아왔다. 아침에도 일찍 일어나는 것이 힘들지 않고, 일어나서 운동도 다니고 공부도 할 수 있는 에너지가 생겼다. 기쁘다. 재택근무 기간이기 때문에 누릴 수 있는 아침 시간의 공부 시간이 굉장히 소중하다. 이걸로 이직을 준비할 수 있는지까지는 의문이지만…갑자기 2년도 전에 염두에 두고 만들지 않았던 기획을 만들어보려고 한다. 내가 생산적인 일을 해야 의욕이 생기는 사람인 걸 조금은 잊고 있었다." }, { "title": "&lt;Leetcode&gt;Subrectangle Queries", "url": "/posts/leet-Subrectangle/", "categories": "Leetcode, medium", "tags": "Leetcode", "date": "2021-09-06 08:30:00 +0900", "snippet": "Subrectangle Queries with Java문제를 처음 봤을 때 테스트에서 인자로 받는 내용이 복잡해서 잘 이해되지 않았다. 자세히 살펴보니 Update()와 getValue()를 호출하는 순서도 다 인자로 주기 위함인데, 굳이 저 내용을 다 설명했어야 했나 싶기도 하다. 설명이 복잡도를 올려서 그렇지 풀이의 난이도는 Easy of Easy 했다.[References]Leet code problems최초의 행렬 구조// The initial rectangle (4x3) looks like:// 1 2 1// 4 3 4// 3 2 1// 1 1 1update를 호출하면 인자로 받은 (row1, col1) 부터 (row2, col2) 까지의 행렬 값을 모두 newValue로 교체subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);// After this update the rectangle looks like:// 5 5 5// 5 5 5// 5 5 5// 5 5 5너무 쉬워서 오히려 내가 놓친게 있는지 고민하게 되는 상황이었고, 테스트 돌려보려고 하는 몇분을 제외하면 로직 짜는데는 1분도 안 걸린 것 같다.public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) { for (int i = row1; i &amp;lt;= row2; i++) { for (int j = col1; j &amp;lt;= col2; j++) { this.rectangle[i][j] = newValue; //System.out.println(&quot;row:&quot;+i+&quot;, col:&quot;+j+&quot;,val:&quot;+this.rectangle[i][j]); } //System.out.println(&quot;&quot;); } }" }, { "title": "Funny funny fun fun, yak shaving", "url": "/posts/migrated/", "categories": "Personal, Diary", "tags": "jekyll", "date": "2021-09-05 20:30:00 +0900", "snippet": "Today’s Yak shaving오랫동안 건드리지 않았던 jekyll 세팅이 깨져있어서(Ruby version 이슈와 Homebrew version이 같이 문제가 생긴 듯) 바로 잡으려고 이리저리 하다가, 약간 열이 올랐다. 이런 일에 내가 시간을 이렇게 써야해?쫓아가면서 Dependency 이슈를 해결하던 중에 마침내 열이 받아서 아예 Homebrew를 지워버리고(일단 화가 나서 하긴 했는데 후폭풍이 두렵긴 하다) 재설치하고서도 왜 안되는지 잘 모르겠어서 별도의 신규 템플릿을 다시 받아서 실행해보니 잘 된다. 화는 났지만서도 어차피 원래 구조가 마음에 안 들었던지라 어디가 꼬였는지 찾기보다는 마음에 드는 템플릿을 찾아야겠다 생각하고 categorizing이 잘 되는 템플릿을 찾아서 받았다. 예전 템플릿도 같은 목적으로 찾긴 했는데, 이번 버전이 훨씬 마음에 든다. 도랑치고 가재 잡았네.Yak Shaving이라고 하는 이유는, 역시 이번 주에도 내가 공부를 하지 않고 주말을 보내기 때문. 문제풀이를 하려면 블로그 환경을 새로 셋업해야 한다고 생각해서였고, 나는 여전히 리트코드 풀이를 하고 싶어하지 않는 느낌이 강하게 든다. 이 세상에서 제일 어려운 것은 우리 호린세스 마음이고, 한 평생 나는 그것을 이해하기 위해서 노력하면서 살 것 같다.Jekyll문제 상황 Ruby Gem dependencies were tied up HomeBrew doesn’t control Ruby version해결 방법 HomeBrew 삭제 후 재설치 그래도 원래 프로젝트가 제대로 돌아가질 않음.. 기존 프로젝트 내의 문제인 것 같아서 새로운 템플릿 다운로드 받아서 실행 역시나 잘 돌아감.. 사실 Ruby 나 HomeBrew를 건드리지 않고 신규 프로젝트를 하나 받아봤으면 원인을 먼저 파악할 수도 있었을 것 같은데 말이죠..어쨌든 마음에 드는 템플릿도 찾았으니 겸사겸사 기분 좋게 생각하기로." }, { "title": "내가 제일 어렵다", "url": "/posts/how-to-live/", "categories": "Personal, Self-reflection", "tags": "", "date": "2021-09-03 00:00:00 +0900", "snippet": "인생을 사는데, 고민이 너무 많은 것일 수도 있겠으나 나 자신을 이해하는 것이 세상 제일 어렵다.프린세스 메이커를 꾸준히 하고 있다는 말이 농담이 아니다. 어떤 생각인건지 무엇을 좋아하는지, 어떻게 살고 싶은지, 무엇이 싫은지 스스로 이유를 이해하기가 쉽지가 않다.요즘의 화두는, 무엇에서 삶의 활력을 얻는가 하는 것이다. 치열하게 살면서 성취하는 삶과 내 인생을 느긋이 관조하며 감각을 느끼면서 사는 삶 중에 무엇이 더 나은가?를 고민하고 있다. 예를 들어 최근에 친구들이 ‘너는 토*형 인재야. 일하는거 보면 그래’라고 이야기하는걸 보고 살짝 충격 받았다. 나는 내 삶이 더 중요하다고 생각하는데 일에서 내 삶의 이유를 찾는 삶이란 말인가?그렇다면 나는 왜 그러한가?성취가 내 삶의 중요한 부분을 차지한다면, 이유는 무엇일까? 내가 더 유능한 사람처럼 여겨지기 때문이다. 유능한 사람이 되는 것은 내게 당연한 일이기도 하다. 늘 그랬고 앞으로도 그러하길 기대한다. 왜? 잘 하지 않으면 나는 가치가 없는 사람인가? 그렇게 생각하지 않는데 잘 하고 싶은 욕망이 있다. 잘 못하는 것도 많지만 노력하고 열심히 해서 잘 하는 것이 나에게 굉장히 긍정적인 감정을 준다. 그래서 내 하루 하루를 누리는 삶을 사는 것이 게을러 보이는 것 같다.삶의 방향성의 문제이다. 삶을 누리면서 사는 삶은 함께 느낄 사람들이 필요하고, 만약 그런 삶을 산다면 어쩌면 가정을 꾸릴 수도 있을 것 같다. 지금처럼 삶을 살면 순간 순간의 향기, 감촉을 놓치게 될 것 같기도 하다. 그런데 지금까지 그렇게 살아와서 별로 걱정이 되지 않는 것이다. 좋은 것을 느끼고, 누리면서 사는 것이 두렵다니 참 하잘 것 없는 고민이다. 열심히 살지 않는 것이 두렵다니 참 걱정도 많다." }, { "title": "동짓날 긴긴 밤을", "url": "/posts/dongJitNal/", "categories": "Personal, Self-reflection", "tags": "", "date": "2020-12-21 00:00:00 +0900", "snippet": "동짓날이라 밤이 길어 평소보다 늦은 시간까지 앉아 생각을 더듬어본다.블로그를 4월 무렵까지 열심히 풀었지만 회사가 코로나 시스템에 적응하고 일이 다시 바빠지면서 손을 놓았다. 회사와 관련한 이런저런 경험들도 스스로에게 투자하는 시간을 줄이는 이유가 되었다. 항상 나는 어떤 사람인지 스스로 깨닫고 싶었고, 나에 대해서 관심이 많은 사람인데도 불구하고, 회사가 주는 목표-와 돈- 그런 것들이 눈앞에 나타나면 나 자신보다는 목표를 이루는데 더 관심이 많다.만드는 것(짧은 단위의 이루는 것), 목표를 이루는 것, 이런 것들이 나에게 많은 활력을 준다고 생각해왔는데 요즘은 그것들 조차도 자본주의 시대의 세뇌라는 생각이 든다. 결국 내가 가지고 있는 “일을 잘하는 사람” 이라는 것에 대한 지향점이 언제부터 있었을까? 그것은 학교의 교육과 사회의 세뇌에 의한 것이 아니었을까. 일 잘하는 사람이 되고 싶은 것은 결국 인정에 대한 욕구이고, 나는어쩌면 교육과정과 방향성을 통해서 그런 것들에 대한 욕구를 주입 받았던 것은 아닐까.일이라는 것을 내 삶의 수단으로 삼으려면 내 삶이 더 주체성을 획득해야 한다. 지금은 일에 매몰된 나 밖에 찾을 수가 없기 때문에 회사의 일이 아무리 잘 흘러가더라도 허무한 것이 아닐까 싶다. 그러나 삶의 주체성 획득이라는 것은 결국 이 시대에 완벽한 자급자족의 환경에 이르지 않으면 무언가-돈, 시간, 명예 등등등-를 포기해야만 얻을 수 있는 것인데 나는 욕심이 많아서 그 무엇도 포기하지 않고 잠을 줄이면서 내 건강을 깎아내고, 수명을 맞바꾼 것이다.이제 여기까지는 각성이 되었다. 그렇다면 다시 돌아가서 삶의 주체성 획득을 두가지 방법으로 할 수 있다는 논리를 세울 수 있다. 한 가지는 지금까지처럼 삶의 방향을 일을 통해서 자아를 실현한다고 믿는 것이다. 두 번째는 덜 먹고, 덜 쓰고, 더 자고, 건강한 삶을 살기 위해 불편을 감수하는 것이다. 삶이란 원하는 것을 모두 다 가질 수 없기에 무엇인가를 내려놓아야 한다. 아직 무엇을 내려놓아야 할 것인지, 아니면 더 원하고 아등바등 움직여야 할 것인지 잘 모르겠다." }, { "title": "Life is a Matter of Direction, Not Speed", "url": "/posts/bunches/", "categories": "Personal, Self-reflection", "tags": "", "date": "2020-06-13 00:00:00 +0900", "snippet": "인생은 방향이 문제지 속도가 문제가 아니라던데, 항상 힘은 있는데 방향을 잡는 것은 참 어렵다.내 인생의 큰 방향성은 언제나 해외-서양-에 진출하는 것이었고, 스무살을 기점으로 근 10여년을 돌이켜보면 어딘지 모르게 마치 보이지 않는 손이 나를 해외 문턱까지 밀어다 놓은 느낌이 들기도 했다. 그리고 지금 이 시점에 고민이 되는 것을 정리해보면, 현재 회사에 다니는 것이 해외로 나가기에 더 나은 선택이냐, 이직을 해서 다시 개발직군에 있는 것이 더 나은 선택이냐 하는 것이 판단이 안 선다는 것.2년은 개발자로서 현업에서 떠나있기에는 너무 긴 시간이라는 느낌은 든다. 나는 꼭 개발자가 아니더라도 해외에서 살 수 있다면 직업을 바꿀 의향도 있다. 하지만 지금 현재로서는 이 회사에 남아있는다고 하더라도 결국에는 개발자로 롤을 바꾸는 것 말고는 다른 대안이 없어보인다. 그러면 이 회사의 SDM들은 개발을 안한지 오래된 직원을 어느 정도까지 수용할 수 있을까, 하는 의문이 드는 것이다. 결국 다시 돌아가는 것이 맞겠지, 라는 생각이 든다." }, { "title": "Add String", "url": "/posts/AddString/", "categories": "Leetcode", "tags": "", "date": "2020-04-06 00:00:00 +0900", "snippet": "이건 오늘 푼 문제로 소소하게 버그를 많이 잡아야 했다. String으로 주어진 숫자를 더해서 다시 스트링으로 return 하라고 했다. 처음엔 예외조건을 유심히 보지 않고 “뭐여…?” 하고 Integer.parseInt와 String.valueOf를 이용해서 한줄로 돌렸다. 그리고 제출했더니 에러가 팡! 이유는, 하나의 스트링이 최대 5000개까지 숫자를 가질 수 있기 때문이었다. 아하하 역시 그렇게 쉬운 문제가…하고 다시 풀어냄. 스트링을 1의 자리부터 하나씩 쪼개서 더해서 올림값을 올려주는 방식을 취하고 더한 결과 값은 StringBuffer에 집어넣은 후, 모든 작업이 완료되면 StringBuffer를 reverse 시켰다.[References]Leet code problems예시: Input1: &quot;10020&quot;Input2: &quot;23&quot;Output: &quot;10043&quot; int len1 = num1.length(); int len2 = num2.length(); int idx1 = 0, idx2 = 0; int ollim = 0; StringBuffer sb = new StringBuffer(); while (len1 &amp;gt; idx1 || len2 &amp;gt; idx2 || ollim &amp;gt; 0) { int val1 = 0; int val2 = 0; if(idx1 &amp;lt; len1) { val1 = Integer.parseInt(String.valueOf(num1.charAt(len1-1-idx1))); } if(idx2 &amp;lt; len2) { val2 = Integer.parseInt(String.valueOf(num2.charAt(len2-1-idx2))); } int sum = val1+val2 + ollim; ollim = 0; if (sum &amp;gt;= 10) { ollim = sum / 10; sum = sum % 10; } sb.append(sum); ++idx1; ++idx2; } return sb.reverse().toStr&#39;ing(); 첫 번째 버그는 올림 이라고 써둔, 말그대로 10을 넘은 올림 값을 어디에서도 초기화 하지 않아서 한번 올림값이 갱신되면 계속 그 올림값이 살아있는 문제가 발생했다. 올림값은 sum에 값을 더해준 후에 바로 초기화 하는 것으로 해결했다.두 번째 버그는 올림을 초기화 하고 나서 따라오는 if 문에 sum값을 넣는게 아니라 value값 두개를 더하기만 했다는 것. 올림이 당연히 제대로 되지 않아서 그것도 fix.전체적으로 헤맸던 것이 처음 생각했던 방향은 index를 사용하는 것이 아니라 각 문자열의 길이를 하나씩 줄여나가면서 while진입 조건으로 사용하려고 했었다. 당연히 index가 필요해졌고, index를 사용하고 나니 굳이 len을 선언해야 할 필요가 있었나 싶다.그리고 while문의 진입 조건으로 올림값이 0이 아닐 때를 집어넣는 것도 중요했다. 왜냐하면 처음 계획은 while문의 조건이 이러했기 때문.while(len1 +1 &amp;gt;= idx1 || len2 +1 &amp;gt;= idx2) {...}즉, 올림이 발생할 수도 있다는 가정을 항상 고려해서 한칸을 더 계산하는 작업을 하는 것이었고 따라서 실제 올림의 발생 여부와 관계없이 0이 하나 더 붙어야 하는 상황이었다. 이걸 개선해 줄 수 있었던 것이 각 숫자의 인덱스를 넘어서는 상황이 오더라도 올림값이 있으면 그 올림값을 덧붙여줄 수 있도록 지금의 while 조건을 추가하는 것이었다. 그리고 +1 을 더하는 상황도 불필요해졌다. 지난주에 너무 고생스러워서 쉽게 풀었더니 행복하다.[References]Leet code problemsSpace complexityO((num1.length || num2.length)+1) 가장 긴 스트링에서 올림을 추가하게 되면 + 1Time complexityO((num1.length || num2.length)+1)[Source code]github repo" }, { "title": "Rotting Oranges", "url": "/posts/OrangeRotting/", "categories": "Leetcode", "tags": "", "date": "2020-04-04 00:00:00 +0900", "snippet": "풀어내는데 1주일 정도 걸린 문제다. 풀다가 지쳐서 포스팅을 미뤘던지라 뒤늦게 포스팅을 하게 되었다. 자세한 문제 내용은 리트코드에서 참조하면 좋겠다. 기억을 위해 간단히 설명하자면 2*2 배열에 0(빈칸), 1(신선한 오렌지), 2(썩은 오렌지ㅠㅠ)를 넣어서 표기하고 1분이 지날 때마다 썩은 오렌지의 상하좌우에 위치한 신선한 오렌지가 썩은 오렌지로 변하는 것이고 배열 안에 있는 오렌지가 모두 썩은 오렌지가 되는데 걸리는 시간을 리턴하거나, 만약 시간이 지나도 썩지 않는 위치에 오렌지가 남아있을 경우 -1 을 리턴하는 것이다.[References]Leet code problems처음 문제를 봤을 때 내부에 오렌지의 위치, 썩음 여부, 썩은 시점을 기록하는 이너 클래스를 만들려고 했다. 작업 도중 그렇게 만들어도 도대체 몇번의 포문을 돌아야 할지, 더 나은 방법이 없을지 고민하게 됐다. 이렇게 무식하게 할리가 없다! 라고 확신을 가지고 다른 방법을 찾는데 이틀 정도 썼고…답답해져서 답을 봤는데 이해가 잘 되지 않아서 시간을 더 썼고, 다음날은 그냥 베꼈는데 에러가 발생해서 뻗었고, 마지막날은 두가지 방법으로 문제풀이를 만들었다. 오늘은 이너클래스 방식으로 정보를 관리하는 방법, 배열 내에 썩은 시점을 숫자로 기록해서 처리하는 방법(답 봄), 큐를 사용하는 방법 총 세 가지를 모두 다 기록해보려고 했는데, 지금보니 이너클래스 버전 소스가 없당…빡쳐서 밀어버렸나봉가…빡치기 전에 답을 한번 봤으면 괜찮았을텐데..아쉽 배열 내에 숫자로 썩은 시점을 기록하는 방법아래 코드에서 보면 결국 삼중포문을 돌아버린다. 삼중 포문 전에 있는 첫번째 이중 포문에서는 주어진 배열 두개를 돌면서 신선한 오렌지인지 여부를 확인한다. 그 다음에는 Fresh Orange numbers 를 가장 외부의 포문에서 체크하고 round(걸린 시간)을 추가한다. 동작은 하지만 For문의 조건에 이렇게 많은 정보를 넣는게 가독성에 좋지 않다고 생각한다. while로 잘 처리할 수 있지 않았을까. 내부의 이중 포문은 다시 주어진 배열을 돌면서 썩은 오렌지를 발견하면 rot 메서드에 보내서 상하좌우를 확인하는데 문제를 단순화 한다는 관점에서 좋게 생각했다. 내가 작성할 때는 저 위치에 if문을 각각 걸어서 배열의 인덱스를 넘어서진 않는지 확인해야 했기 때문이다.rot 은 그런 점에서 or 조건 한방으로 인덱스의 길이를 넘어서진 않는지? 혹은 -1위치를 가리키지는 않는지? 등을 모두 확인해버려서 좀 더 깔끔해지긴 한다. public int orangesRotting(int[][] grid) { int round = 0; int fresh = 0; for (int i = 0; i &amp;lt; grid.length; i++) { for (int j = 0; j &amp;lt; grid[i].length; j++) { if(grid[i][j] == 1) fresh++; } } for(int oldFresh= fresh; oldFresh&amp;gt;0; round++, oldFresh=fresh){ for(int i = 0; i&amp;lt; grid.length; i++){ for(int j = 0; j&amp;lt; grid[i].length; j++){ if(grid[i][j] == round+2) { fresh -= rot(grid, i+1, j, round) + rot(grid, i-1, j, round) + rot(grid, i, j+1, round) + rot(grid, i, j-1, round); } } } if(fresh == oldFresh) return -1; } return round; } private int rot(int[][] grid, int i, int j, int day) { if(i&amp;lt;0 || j&amp;lt;0 || i&amp;gt;=grid.length || j&amp;gt;=grid[i].length || grid[i][j] != 1) return 0; grid[i][j] = day + 3; return 1; }Space complexityO(n): 원래 배열만 사용Time complexityO(n^3): 삼중포문..맞는거지? 전체 배열이 모두 다 신선한 오렌지일 수 있기 때문에 최악의 경우에는 삼중 포문을 아주 꽉꽉(꽉꽉 이래도 아마 n보다 작은 상수겠지만 )돌아야 할 수도 있다는 것. Queue를 활용한 것마찬가지로 첫번째 포문은 전체 배열을 순회하면서 썩은 오렌지가 있으면 썩은 오렌지의 위치와 썩은 시점을 Pair객체로 집어넣는 것이다. 그리고 while문을 돌면서(도는 횟수를 ++시켜서 최종 값이 다 썩는데 걸린 시간) 썩은 오렌지가 빌 때까지 queue를 비운다. 그리고 그 썩은 오렌지의 상하좌우에 신선오렌지가 있는지 확인하고, 있다면 그 오렌지도 썩은 오렌지로 표기해서 큐에 넣는다. 큐가 다 비었는데 아직 안 썩은 오렌지의 개수가 남아있다면? -1을 리턴하면 된다.public int orangesRottingWithQueue(int[][] grid) { Queue&amp;lt;Pair&amp;lt;int[], Integer&amp;gt;&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); int fresh = 0; int round = 0; for (int i = 0; i &amp;lt; grid.length; i++) { for (int j = 0; j &amp;lt; grid[i].length; j++) { int orange = grid[i][j]; if(orange == 2) { q.add(new Pair(new int[] {i, j}, 0)); } if (orange == 1) { fresh++; } } } while(!q.isEmpty()) { Pair&amp;lt;int[], Integer&amp;gt; p = q.poll(); int row = p.getKey()[0]; int col = p.getKey()[1]; int rottenRound = p.getValue(); round = rottenRound; //upper i-1, j if(row -1 &amp;gt;= 0 &amp;amp;&amp;amp; grid[row-1][col] == 1) { grid[row-1][col] = 2; fresh--; q.add(new Pair (new int [] {row - 1, col}, rottenRound +1)); } //below i+1, j if(row +1 &amp;lt; grid.length &amp;amp;&amp;amp; grid[row+1][col] == 1) { grid[row+1][col] = 2; fresh--; q.add(new Pair(new int[] {row + 1, col}, rottenRound +1)); } //left i, j-1 if(col -1 &amp;gt;= 0 &amp;amp;&amp;amp; grid[row][col-1] == 1) { grid[row][col-1] = 2; fresh--; q.add(new Pair(new int[] {row, col - 1}, rottenRound +1)); } //right i, j+1 if(col +1 &amp;lt; grid[row].length &amp;amp;&amp;amp; grid[row][col+1] == 1) { grid[row][col +1] = 2; fresh--; q.add(new Pair(new int[]{row, col + 1}, rottenRound+1)); } } return (fresh &amp;gt; 0) ? -1:round; }Space complexityO(n): 썩은 오렌지 개수만큼 큐를 사용한다네Time complexityO(n): 썩은 오렌지 하나가 들어갈 때마다 다른 오렌지들이 또 들어간다네.[Source code]github repo" }, { "title": "Longest Parlinedrome", "url": "/posts/longest-parlindrome/", "categories": "Leetcode", "tags": "", "date": "2020-03-31 00:00:00 +0900", "snippet": "지난 주의 문제가 이번 주까지 넘어왔다. 주어진 스트링에서 가장 긴 회문을 찾아서 잘라내어 리턴하는 것이 이 문제의 요구사항이었다. 직접 풀지 못하고 솔루션을 참고함.예시: Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; 도 가능오전에 문제풀이를 시작하고 혼자서 어영부영 답을 내지 못한 문제는 이번이 처음이었다. 그냥 답도 베껴보았다. 이거 easy라더니 누가 easy래…나의 자신감을 깎아먹어버림. int low, maxlen; public String longestPalindrome(String s) { int len = s.length(); if(len&amp;lt;2) { return s; } for (int i = 0; i &amp;lt; len - 1; i++) { extendIdx(s, i, i); extendIdx(s, i, i + 1); } return s.substring(low, low+maxlen); } private void extendIdx(String s, int j, int k) { while(j &amp;gt;= 0 &amp;amp;&amp;amp; k&amp;lt; s.length() &amp;amp;&amp;amp; s.charAt(j) == s.charAt(k)) { j--; k++; } if(maxlen &amp;lt; k-j-1) { low = j +1; maxlen = k - j - 1; } } 두번째 테스트 같은 경우에는 좀 의아할 수 있는데, 코드 상에서 주석을 보더라도 예상할 수 없다. 원래 while문을 돌 때 같을 떄 조건도 안에 함께 포함되어 있었고 즉 A를 세번 반복했을 떄 B는 substring이 아니라서 -1을 리턴해버리는 문제가 있었다. 그걸 해결하려고 주석 내부의 for문을 추가한건데, 결국 다른 사람의 솔루션을 확인하니 딱 두번만 더 확인하면 되니 if두개로 확인하는 것을 보고 나쁘지 않다는 생각이 들어서 추가했다. 내용은 결국 같다.[References]Leet code problemsSpace complexityO(n): B만큼의 혹은 약간 더 긴 StringBuilder(builder가 속도가 빠르더라)Time complexityO(n): B만큼의 길이를 while문을 돌아야 하니 O(B/A)—[Source code]github repo" }, { "title": "Repeated String Match", "url": "/posts/Repeated-string-match/", "categories": "Leetcode", "tags": "", "date": "2020-03-26 00:00:00 +0900", "snippet": "오늘의 문제는[References]Leet code problems[풀이] //PUT codeSpace complexity[여기 설명]Time complexity[여기 설명][Source code]github repo[References]Leet code problems" }, { "title": "License Key Format", "url": "/posts/licensektyformat/", "categories": "Leetcode", "tags": "", "date": "2020-03-25 00:00:00 +0900", "snippet": "오늘의 문제는 주어진 String license를 두번째 인자로 주어진 숫자 크기에 맞춰 ‘-‘ 대쉬를 입력하고, 또 전체를 대문자로 바꾸는 문제였다. 단 수트링의 길이가 만약 주어진 숫자의 배수가 아닐 경우, 나머지(K보다 짧은 스트링)는 앞에 배치한다. 설명이 힘드네…아래 샘플이 있다.Input: S = &quot;2-5g-3-J&quot;, K = 2Output: &quot;2-5G-3J&quot;[Leet code problem link] (https://leetcode.com/problems/license-key-formatting/)처음에는 Stack에 쌓아넣고 하나씩 뽑아내는 방식을 생각했다. 그런데 숫자의 크기만큼 대시를 집어넣는 방식이 뒤에서부터 진행돼야 한다는 것을 깨달았다. 그래서 스택을 포기하고 스트링버퍼를 뒤집는걸 생각했다. 틀렸던 테스트 케이스가 나왔는데 알파벳은 없이 “——“라고 나온 것들. 그걸 해결 하기 위해서는 소스의 위치를 변경할 필요가 있었는데, 대쉬 기호를 어느 시점에 붙여주느냐의 문제. 나는 일단 주어진 숫자의 크기를 다 채우면 무조건 앞에 대쉬를 붙여줬다. 즉 아래 소스의 두 번째 if문이 원래 for loop의 가장 마지막에 있었던 것. 그래서 처음 소스에서는 마지막에 다 돌고 나서 리턴 값 앞에 대쉬기호가 있는지 확인하고 지우는(sb 인덱스 삭제할 때 array copy한다..ㅂㄷ) 작업을 따로 했는데, 다 완료 하고 나서 솔루션을 보니 카운트를 앞으로 내보내고 카운트를 뒤에 ++시키는 방법도 있었다. 즉 다음 번 포문을 돌 때 붙여야 할 차례인지를 확인하는 것. 똑같은 코드를 훨씬 줄일 수 있었다. public String licenseKeyFormatting(String S, int K) { StringBuffer sb = new StringBuffer(); int count = 0; for (int i = S.length()-1; i &amp;gt;=0; i--) { if (S.charAt(i) == &#39;-&#39;){ continue; } if (count == K) { count = 0; sb.append(&#39;-&#39;); } sb.append(Character.toUpperCase(S.charAt(i))); count++; } return sb.reverse().toString(); }Space complexityO(n): string에 만약 주어진 내용이 모두 알파벳이라면 O(n + n/k) == O(n)Time complexityO(n). StringBuffer reverse 도 bit 연산으로 한번에 옆으로 쭉 땡기는 듯. 다행이다.[Source code]github repo[References]Leet code problems" }, { "title": "Squares of a sorted Array", "url": "/posts/Squares-of-a-sorted-array/", "categories": "Leetcode", "tags": "", "date": "2020-03-24 00:00:00 +0900", "snippet": "오늘의 문제는 sorted된 array(including negative)의 square 값들을 sorted array로 다시 만들어서 내보내는 것이었다.Challenge 1for loop list에 제곱해서 집어넣은 다음에 리스트 자체를 Collections.sort로 해결. 다시 int array로 돌리기 위해 for loop 를 다시 돌았음. 직관적으로 생각이 들었고 동작하는거 본 다음에 linked list로 포문을 한번만 돌면서 할 수 있을거라고 생각함. submit 성공. public int[] sortedSquares_easy(int[] A) { List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for (int i:A) { list.add(i*i); } Collections.sort(list); int[] result = new int[list.size()]; for (int i = 0; i &amp;lt; list.size(); i++) { result[i] = list.get(i); } return result; }Space complexityO(n): A.length 만큼 *2번새로운 배열을 선언Time complexityCollections.sort 만큼의 시간 복잡도가 될 것.Challenge 2샘플 문제는 동작하는데 time limit에 걸려서 submit을 받아주지 않음. 1번 답을 생각하면서도 어렴풋이 링크드 리스트로 해결할수 있을거라고 생각했던 것은 linkedlist를 한번만 돌면서 중간에 끼워넣을 수 있으니까 성능이 더 좋을거라고 생각했는데, 짜다보니 double for loop 를 만들어버린 것이어따…중간에 반성했지만 일단 돌아가는지 보고 싶어서 실행. 10000개짜리 테스트 케이스에서 깨졌다. public int[] sortedSquares_linkedlist(int[] A) { LinkedList&amp;lt;Integer&amp;gt; list = new LinkedList&amp;lt;&amp;gt;(); for (int i:A) { int current = 0; int idx = 0; for(int j = 0; j &amp;lt; list.size(); j++) { current = list.get(j); if (current &amp;gt;= i * i) { break; } idx++; } list.add(idx, i*i); } int[] result = new int[list.size()]; for (int i = 0; i &amp;lt; list.size(); i++) { result[i] = list.get(i); } return result; }Space complexityO(n): A.length 만큼 *2번새로운 배열, 링크드 어레이 선언Time complexityO(n^2)Solution 참고더 나은 생각이 들지 않아서 솔루션을 봤는데, 내가 무심히 놓친 부분이 시작할 때 주어지는 array가 이미 sorted라는 것이다. 이미 정렬되어 있다는 부분에서 얻을 수 있는 것..양쪽 끝이 가장 클 가능성이 높은 두 수라는 것. 이걸 고려하지 않았기 때문에 더 새로운 아이디어가 나올 수 없었다. 문제를 잘 읽자.양쪽의 index를 각각 head, tail 로 놓고 while문을 돌면서 제곱승을 해서 더 큰 숫자를 사전에 선언해둔 배열의 끝부터 채워넣는다. 처음에 실패했었는데, 그 이유는 tail도 ++시켜서 신나게 Array outof index 가 떨어졌고 디버깅하다보니 tail놈이 ++되고 계셔서 고침. 두번째도 에러가 났는데 두번째에는 answeridx를 옮겨주지 않고 제일 끝 자리만 계속 갱신하고 있어서 고침. public int[] sortedSquares_solutionWithMergeSort(int[] A) { int head = 0; int tail = A.length-1; int[] answer = new int[A.length]; int answerIdx = A.length-1; while(head &amp;lt;= tail) { int headSquared = A[head]*A[head]; int tailSquared = A[tail]*A[tail]; if(headSquared &amp;gt;= tailSquared) { answer[answerIdx] = headSquared; head++; } else { answer[answerIdx] = tailSquared; tail--; } answerIdx--; } return answer; }Space complexityO(n) : return 하는 새로운 배열 크기Time complexityO(n) : A의 길이만큼 한번 실행 word의 자리수 만큼 O(word.length) 키보드의 indexOf를 할 떄 주어진 키보드 스트링 길이만큼 순회해야 하니 O(keyboard.length)[Source code]github repo[References]Leet code problems" }, { "title": "Single row keyboard", "url": "/posts/Single-row-keyboard/", "categories": "Leetcode", "tags": "", "date": "2020-03-23 00:00:00 +0900", "snippet": "오늘의 문제는 두개의 문자열-26자리의 순서가 없는 알파벳 세트 하나와 특정한 단어-을 주고 두번째 단어를 알파벳 세트에서 인덱스로 가리키기 위해서 몇 번을 인덱스가 옮겨다녀야 하느냐 하는 것이었다.답도 줬다. |i - j | 가 답이라고…ㅎㅎ오래 고민하지 않았고, 실수가 있었다면 목표지점까지 도착했을 때 인덱스를 교체해주지 않은 점.public int calculateTime(String keyboard, String word) { int idx = 0; int count = 0; for (char alphabet: word.toCharArray()) { int newIdx = keyboard.indexOf(alphabet); count += Math.abs(newIdx - idx); idx = newIdx; } return count; }Space complexityO(1) 인덱스, 카운트 개수 만큼Time complexityO(n*m)word의 자리수 만큼 O(word.length) 키보드의 indexOf를 할 떄 주어진 키보드 스트링 길이만큼 순회해야 하니 O(keyboard.length)[Source code]github repo[References]Leet code problems" }, { "title": "Unique Morse Code Words", "url": "/posts/Unique-morse-code-words/", "categories": "Leetcode", "tags": "", "date": "2020-03-20 00:00:00 +0900", "snippet": "오늘의 릿콛 문제 풀이는 주어진 String array에 있는 String을 몰스 부호로 바꿔서 concatenation할 때 같은 결과가 있는지 확인하는 것이었다.책에서 읽던 모스 부호가 Morse code라고 쓰는 것을 오늘 배웠다. 오 모스 부호! 라고 문제를 읽고 잠시 후에 반가워했다. 물론 반가워 할 이유도 없다. 몰 부호 SOS도 모른다. 아는 것이라서 반가웠나? 한번에 방향을 잡았고 문제를 푸는데는 10분 정도 걸렸다. 최초에 시간을 좀 썼던 이유는 Character에서 ‘a’를 뺀 것으로 주어진 몰스 부호의 인덱스를 잡으려고 했는데 string.indexOf(0) 을 하면 첫번째 캐릭터가 나올 줄 알았는데 아니었다. charAt을 써야 하는데 너무 확신을 가지고 찍어보다보니 시간이 오래 걸렸다.몰스 부호로 변환하는대로 HashSet에 집어넣고 나중에 해시셋의 사이즈를 리턴했다. 역시나 메모리는 꼴등에 가깝게 잡아먹었지만 속도는 1등!public int uniqueMorseRepresentations(String[] words) { String[] morseTable = {&quot;.-&quot;, &quot;-...&quot;, &quot;-.-.&quot;, &quot;-..&quot;, &quot;.&quot;, &quot;..-.&quot;, &quot;--.&quot;, &quot;....&quot;, &quot;..&quot;, &quot;.---&quot;, &quot;-.-&quot;, &quot;.-..&quot;, &quot;--&quot;, &quot;-.&quot;, &quot;---&quot;, &quot;.--.&quot;, &quot;--.-&quot;, &quot;.-.&quot;, &quot;...&quot;, &quot;-&quot;, &quot;..-&quot;, &quot;...-&quot;, &quot;.--&quot;, &quot;-..-&quot;, &quot;-.--&quot;, &quot;--..&quot;}; char startIndex = &#39;a&#39;; Set&amp;lt;String&amp;gt; morseSet = new HashSet&amp;lt;&amp;gt;(); for (String word: words) { StringBuffer sb = new StringBuffer(); for (char alphabet : word.toCharArray()) { sb.append(morseTable[alphabet - startIndex]); } String morseConverted = sb.toString(); morseSet.add(morseConverted); } return morseSet.size(); }Space complexitywords 가 모두 다른 몰스 코드 결과로 리턴될 수 있으니 O(n)Time complexityO(n*l). n은 words의 개수. l은 각 단어의 길이.[Source code]github repo[References]Leet code problems" }, { "title": "Jewels and Stones", "url": "/posts/New-Jewels-In-Stones/", "categories": "Leetcode", "tags": "", "date": "2020-03-19 00:00:00 +0900", "snippet": "오늘의 알고리즘은 String 2개가 주어진 상태에서 J에 포함되어 있는 character가 S에 몇번 존재하는지를 확인하는 것이었다.제일 첫 번째 시도는 HashMap을 이용, S의 char을 하나씩 map에 집어넣으면서 value를 하나씩 ++ 시켜주었다. 그리고 J의 for loop을 돌면서 해당하는 키가 map에 존재하는지 확인하고 map에 있으면 값을 더해서 돌려주는 것으로. 첫 번쨰 시도에서 submit에 성공했으나 메모리 사용 수준이 95% 순번이라 수정해보기로 했다. Map&amp;lt;Character, Integer&amp;gt; stoneMap = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; S.length(); i++) { stoneMap.put(S.charAt(i), stoneMap.getOrDefault(S.charAt(i), 0)+1); } int count = 0; for (int i = 0; i &amp;lt; J.length(); i++) { count += stoneMap.getOrDefault(J.charAt(i), 0); } return count;solution을 확인해보니 map이 아니라 set을 사용해서 contains로 확인하는 케이스가 있었다. set에 J캐릭터를 모두 넣고 S를 돌면서 있는지 확인하고 contains true가 나오면 넘어가는 것. 메모리를 줄이는데는 도움이 되지 않았다. Set&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); int result = 0; for (char c: J.toCharArray() ) { set.add(c); } for (char s : S.toCharArray()) { if(set.contains(s)) result++; } return result;마지막 시도였으나 역시 메모리를 줄이는데 도움이 되지는 않았다. 하지만 속도가 빨라졌다. Hashmap을 쓰지 않아서 그런 것 같다. S를 돌면서 J의 해당 캐릭터 인덱스가 없으면 (== -1) 넘어가는 것. int count = 0; for (char c : S.toCharArray()) { if(J.indexOf(c) != -1) count++; } return count;Space complexityhash를 쓰는 방법으로는 S or J의 크기만큼 map 공간을 사용하게 되니 O(n)세번쨰 방법은 주어진 J와 S를 그대로 쓰고 새로운 공간을 사용하지 않기 때문에 O(1)Time complexityHash를 쓰는 방식은 O(J+S) for 문을 두번 다 도는 것 밖엔 답이 없다. 하지만 마지막 방법은 O(S)작성한 코드는 요기에: my leetcode repo[References]Leet code problems" }, { "title": "Find Anagram Mappings", "url": "/posts/Find-Anagram-Mappings/", "categories": "Leetcode", "tags": "", "date": "2020-03-18 00:00:00 +0900", "snippet": "오늘의 알고리즘은 주어진 array 2개를 비교하여 두 번째 배열의 아이템이 첫 번째 배열의 몇 번째 아이템이었는지 각각 확인하고 순서를 다시 int 배열로 만드는 것이었다.HashMap을 이용, for loop을 돌면서 두번째 array의 순서를 item:array number 형식으로 저장하고 다시 첫번째 배열을 for loop을 돌면서 해당 item의 값을 hashmap에서 찾아서 결과로 리턴할 배열의 값에 밀어넣었다.Space complexity HashMap에 put 하기 때문에 최대 주어진 배열 B 길이만큼 공간을 사용(O(n))Time complexityfor loop을 두번 돌아 2n, 상수 제거하고 O(n)작성한 코드는 요기에: my leetcode repo[References]Leet code problems" }, { "title": "Unique Email Addresses", "url": "/posts/Unique-Email-Addresses/", "categories": "Leetcode", "tags": "", "date": "2020-03-17 00:00:00 +0900", "snippet": "오늘의 알고리즘은 email로 구성된 String 리스트를 주고, dot(.)과 plus(+) 기호의 예외 처리를 한 후 실제 unique한 email 주소의 개수를 리턴하는 것이었다.email 주소라서 왠지 친근한 감이 있었다. java String의 split과 replace를 사용해서 처리했다. 첫 제출에 실수가 있었는데, 도메인을 따로 떼어놓지 않고 계속 같이 스트링에 넣어둔 상태로 사용해서 그런 것.foreach를 돌면서 전체 리스트를 순회, 각 email주소에서 도메인을 뜯어내고, .과 +를 대체하는 작업을 완료 후 미리 선언해둔 HashSet에 저장해서 중복을 처리하고 최종적으로는 HashSet의 크기로 값을 리턴.for (String email :emails) { sb.delete(0, sb.length()); String[] parts = email.split(&quot;@&quot;); String withoutPlus= parts[0].split(&quot;\\\\+&quot;)[0]; sb.append(withoutPlus.replace(&quot;.&quot;, &quot;&quot;)); sb.append(&quot;a&quot;); sb.append(parts[1]); hset.add(sb.toString());}split은 regex를 사용하기 때문에 성능이 좋지 않다는 말도 있지만 손에 익은 함수가 최선이라고 생각했다.replace는 다시 확인해보니 안에서 replaceAll을 호출하고 while문을 돌기 때문에 직접 구현해도 다를 바가 없다고 생각해서 유지했음.나중에 성능이 썩 좋진 않아서(상위 30프로 정도) 수정하려고 해봤지만 내 코드로는 더 개선이 어려웠다. 솔루션을 확인하니 String buffer가 있어서, 사용했더니 성능 개선!Space complexityHashSet에 add하기 때문에 최대 전체 String 배열의 길이만큼 공간을 사용(O(n))Time complexityforeach에서 O(n)(주어진 리스트의 길이만큼 순회),매 foreach에서 첫번째 split에서 O(해당 문자열.length)매 foreach에서 두번째 splitdㅔ서 O(해당 문자열의 주소 부분의.length)매 foreach에서 replace하면서 (해당 문자열의 주소부분의 length)이러면 O(n)으로 해도 될듯.작성한 코드는 요기에: my leetcode repo[References]Leet code problems" }, { "title": "Palindrome permutation", "url": "/posts/Parlindrom-exist/", "categories": "Leetcode", "tags": "", "date": "2020-03-16 00:00:00 +0900", "snippet": "오늘의 알고리즘은 주어진 문자열의 순열이 palindrome(회문: 수박수박수)을 구성할 수 있는가 하는 문제였다.헷갈려서 solution을 확인했는데, 나는 “permutation of the string could form a palindrome” 이라는 부분을 스트링의 일부가 회문 형식으로 구성될 수 있느냐는 것으로 이해해버림. Permutation에 대한 내용을 무시해버린 것이다. 덕분에 상당한 시간을 삽질에 쏟았고, 이게 easy레벨이야?ㅠㅠ하면서 솔루션을 확인했다.확인 결과 우선 문제를 잘못 이해했음을 깨달았고, 내용을 읽으면서 이미 답을 봐 버렸기 때문에 실제로 코드를 짜는 시간은 오래 걸리지 않았다.주어진 문자열의 순열이 회문이어야 하기 때문에 해당하는 경우는 두 가지 뿐이다. 전체 문자열의 캐릭터가 각각 2개씩 쌍을 이루고 있거나, 오직 하나의 홀수 캐릭터를 가지고 있거나.&quot;aba&quot; -&amp;gt; 홀수인 캐릭터 b가 하나 뿐이니 가능&quot;aabbaa&quot; -&amp;gt; 전체가 짝수이니 가능&quot;abc&quot; -&amp;gt; 홀수인 캐릭터가 세개라서 불가능&quot;ab&quot; -&amp;gt; 홀수인 캐릭터가 두개라서 불가능Space complexityHashMap에 집어넣고 카운트를 하면서 전체 문자열의 길이만큼 공간을 확보(O(n))Time complexityHashMap에 집어넣는데 O(n), 다 집어넣고 나서 foreach문을 돌면서 다시 짝/홀수 여부를 확인해야 하기 떄문에 여기서도 최악의 경우 O(n). 최대 O(n)작성한 코드는 요기에: my leetcode repo[References]Leet code: " }, { "title": "IntelliJ Live template", "url": "/posts/intellij_live_template/", "categories": "Productivity", "tags": "IntelliJ", "date": "2020-03-11 00:00:00 +0900", "snippet": "내가 사랑하는 Intellij는 사소한 반복을 줄여서 productivity의 향상을 지원하고, 이것은 곧 나의 Performance에 영향을 미친다.카카오를 퇴사하면서 사용하던 인텔리제이 설정을 export하지 않았다. 그 때 당시에는 내가 해놓은 설정이 그렇게 소중하다는 생각을 해본 적이 없었다. 하지만 몇 년 간의 습관이 하나하나 쌓여 Intellij 에 설정되어 있었다. 모두 다 내 생산성에 큰 영향을 미치는 자산인데 그 때는 하나씩 하나씩 설정했던 것들이 그렇게 많다고 체감하지 못했던 것이다.(그리고 설정을 밀고…회사 컴을 새로 받고…갠컴도 새로 사고…지금은 습관에 맞춰 설정을 찾아가는 상태)그 중에서도 없으면 불편한 줄 모르고 쓰지만 있으면 또 중독되는 것이 Live template이다. 입사 초기에 시니어 개발자 분이 알려주셔서 늘 유용하게 써먹고 있다(THX to Dex). 그런데 오랜만에 새로운 설정을 하러 들어갔더니 원하는대로 동작하지 않아서 확인하던 차에, 이 라이브 템플릿을 입력하는 창 아래에 있는 No applicable contexts를 클릭해서 사용하려는 언어로 셋업해줘야 동작한다는 것을 다시 기억해냈다. 이건 영어로 된 문서에도 나와 있지만 누가 문서를 그렇게 열심히 읽겠는가. 그래서 놓쳤다.겸사 겸사 읽으러 들어간 문서에 이미 정의되어 있는 live template에서 사용 가능한 함수 등을 새롭게 발견해서 덧붙인다.예를 들어 아래와 같은 라이브 템플릿을 만든다고 가정하면for (int i = 0; i &amp;lt; $END$; i+) { // created on $DATE$ by $USER$}edit variable 세팅에서 이미 정의된(predefined) date() 함수를 $DATE$에 할당해서 오늘 날짜가 자동으로 입력하고, $USER$ 에는 user() 함수를 할당해서 코드 작성자의 이름이 바로 입력되도록 할 수 있다. 이름은 그냥 내 이름 하드코딩하면 되는데…? 라고 생각했는데 이 live template을 share하는 기능도 있는 것으로 보아 다른 사람들과 공유할 때 헷갈리지 말라고 있는 기능인 듯.앞으로 사용할 예약어(abbreviation)를 정의하면 위의 템플릿은 아래와 같이 변경되고 변수를 확인하는 차원에서 엔터 키를 쳐주면 $END$ 변수가 정의되어 있는 위치에서 커서가 깜박거리고 기다리고 있다. 내가 채워줘야 하는 부분에 END 변수를 넣어주면 좀 더 편리하다.평소에 자주 사용하던 sout도 내장된 라이브 템플릿의 하나였고 fori, ifn(if null) 등이 사전에 정의되어 있는 것을 확인했으니 생산성을 위해서 검토해 볼 만하다.나는 이미지 따위는 캡쳐해서 올리지 않는다…인터넷에 한글로 검색하면 gif 로 올라온거 많다….[References]live tamplate predefined functions " } ]
